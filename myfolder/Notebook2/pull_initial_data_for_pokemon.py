# -*- coding: utf-8 -*-
"""Pull initial data for pokemon

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ax5Q6QDN93WNpc8-UOHGM55p42pzajdB
"""

import requests
import random
import json
import pprint
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
import matplotlib.cm as cm
from sklearn.cluster import KMeans


def get_pokemon_data(name):
    url = f"https://pokeapi.co/api/v2/pokemon/{name.lower()}"
    response = requests.get(url)

    if response.status_code != 200:
        print(f"Data not found for {name}")
        return None

    data = response.json()

    stats = {stat['stat']['name']: stat['base_stat'] for stat in data['stats']}
    types = [type_info['type']['name'] for type_info in data['types']]
    moves = [move_info['move']['name'] for move_info in data['moves']]
    species_url = data["species"]["url"]

    return {
        'Name': data['name'],
        'Base Stats': stats,
        'Types': types,
        'Moves': moves,
        "species_url": species_url
    }

def get_move_data(move_name):
    """
    Fetch detailed move data from PokéAPI with name normalization.
    """
    import re
    base_url = "https://pokeapi.co/api/v2/move/"

    # Normalize name: lowercase, hyphens instead of spaces, remove apostrophes/periods
    normalized_name = move_name.strip().lower()
    normalized_name = normalized_name.replace(" ", "-").replace("'", "").replace(".", "")
    normalized_name = re.sub(r"[^\w\-]", "", normalized_name)  # remove any remaining non-URL-safe chars

    url = f"{base_url}{normalized_name}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        move = response.json()
        return {
            "name": move["name"],
            "type": move["type"]["name"],
            "power": move["power"],
            "accuracy": move["accuracy"],
            "pp": move["pp"],
            "damage_class": move["damage_class"]["name"],
            "effect_chance": move.get("effect_chance"),
            "short_effect": (
                move["effect_entries"][0]["short_effect"]
                if move.get("effect_entries") else "No effect info."
            ),
            "meta": move.get("meta", {})
        }
    except Exception as e:
        print(f"⚠️ Could not retrieve move data for '{move_name}': {e}")
        return None


def get_nature_details(nature_name):
    """
    Fetches nature details from the PokeAPI.

    Args:
        nature_name (str): The name of the nature.

    Returns:
        dict: A dictionary containing increased and decreased stats, or None if not found.
    """
    url = f"https://pokeapi.co/api/v2/nature/{nature_name.lower()}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        increased_stat = data["increased_stat"]["name"] if data["increased_stat"] else None
        decreased_stat = data["decreased_stat"]["name"] if data["decreased_stat"] else None
        return {"increased": increased_stat, "decreased": decreased_stat}
    else:
        print(f"Nature details not found for {nature_name}")
        return None

def get_item_data(item_name):
    url = f"https://pokeapi.co/api/v2/item/{item_name}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return {
            "name": data["name"],
            "category": data["category"]["name"],
            "effect": data["effect_entries"][0]["effect"] if data["effect_entries"] else "",
            "attributes": [attr["name"] for attr in data["attributes"]]
        }
    else:
        return None

def get_type_effectiveness_data():
    """
    Gets type effectiveness data from the PokeAPI.

    Returns:
        dict: A dictionary where keys are attacking type names and values are
              dictionaries containing damage multipliers against other types.
              Returns an empty dictionary if data cannot be fetched.
    """
    type_effectiveness = {}
    url = "https://pokeapi.co/api/v2/type/"
    response = requests.get(url)

    if response.status_code != 200:
        print("Could not fetch list of types.")
        return type_effectiveness

    types_data = response.json()
    type_urls = [t['url'] for t in types_data['results']]

    for type_url in type_urls:
        type_response = requests.get(type_url)
        if type_response.status_code == 200:
            type_details = type_response.json()
            type_name = type_details['name']
            damage_relations = type_details['damage_relations']

            effectiveness_for_type = {}
            for rel_type in damage_relations['double_damage_to']:
                effectiveness_for_type[rel_type['name']] = 2.0
            for rel_type in damage_relations['half_damage_to']:
                effectiveness_for_type[rel_type['name']] = 0.5
            for rel_type in damage_relations['no_damage_to']:
                effectiveness_for_type[rel_type['name']] = 0.0

            type_effectiveness[type_name] = effectiveness_for_type
        else:
            print(f"Could not fetch details for type: {type_url}")

    return type_effectiveness

def get_type_effectiveness(attacking_type, defender_types):
    """
    Calculates the overall damage multiplier based on attacking and defending types.

    Args:
        attacking_type (str): The name of the attacking type.
        defender_types (list): A list of names of the defending types.

    Returns:
        float: The overall damage multiplier.
    """
    total_effectiveness = 1.0

    if attacking_type not in type_effectiveness_data:
        return total_effectiveness

    effectiveness_for_attacking_type = type_effectiveness_data[attacking_type]

    for defender_type in defender_types:
        if defender_type in effectiveness_for_attacking_type:
            total_effectiveness *= effectiveness_for_attacking_type[defender_type]

    return total_effectiveness

def calculate_hp(base_hp, iv, ev, level):
    """Calculates a Pokémon's actual HP stat."""
    return int(((2 * base_hp + iv + int(ev/4)) * level) / 100) + level + 10

def calculate_stat(base_stat, iv, ev, level, nature_mod):
    """Calculates a Pokémon's actual non-HP stat."""
    return int((((2 * base_stat + iv + int(ev/4)) * level) / 100) + 5) * nature_mod

# Define item multipliers
item_multipliers = {
    "choice-band": {"stat": "attack", "multiplier": 1.5},
    "choice-specs": {"stat": "special-attack", "multiplier": 1.5},
    "choice-scarf": {"stat": "speed", "multiplier": 1.5},
    "life-orb": {"stat": "damage", "multiplier": 1.3},
    "muscle-band": {"stat": "attack", "multiplier": 1.1},
    "wise-glasses": {"stat": "special-attack", "multiplier": 1.1},
    "assault-vest": {"stat": "special-defense", "multiplier": 1.5},
    "quick-claw": {"stat": "priority", "multiplier": 1.0},
    "light-clay": {"stat": "screens", "multiplier": 1.0},
}

# Fetch type effectiveness data
type_effectiveness_data = get_type_effectiveness_data()

def get_all_pokemon_names(limit=10000):
    url = f"https://pokeapi.co/api/v2/pokemon?limit={limit}"
    response = requests.get(url).json()
    names = [pokemon['name'] for pokemon in response['results']]
    return names

all_pokemon_names = get_all_pokemon_names()

all_pokemon_data = []
for name in all_pokemon_names:
    pokemon_data = get_pokemon_data(name)
    if pokemon_data:
        all_pokemon_data.append(pokemon_data)

def get_generation_from_species_url(species_url):
    response = requests.get(species_url)
    if response.status_code != 200:
        print(f"Generation info not found for species: {species_url}")
        return None

    data = response.json()
    return data["generation"]["name"]

gen_map = {
    "generation-i": "Gen I",
    "generation-ii": "Gen II",
    "generation-iii": "Gen III",
    "generation-iv": "Gen IV",
    "generation-v": "Gen V",
    "generation-vi": "Gen VI",
    "generation-vii": "Gen VII",
    "generation-viii": "Gen VIII",
    "generation-ix": "Gen IX"
}

for pokemon in all_pokemon_data:
    pokemon["generation"] = get_generation_from_species_url(pokemon["species_url"])
    pokemon["generation"] = gen_map.get(pokemon["generation"], pokemon["generation"])
    pokemon["Total Base Stats"] = sum(pokemon["Base Stats"].values())

display(all_pokemon_data[0])

"""**Reasoning**:
Create a new cell containing the functions for calculating and modifying stats as requested in the subtask.


"""

def apply_nature_to_stats(stats, nature_name):
    """
    Applies the stat multipliers based on a nature to a Pokémon's stats.

    Args:
        stats (dict): A dictionary of a Pokémon's base stats.
        nature_name (str): The name of the nature to apply.

    Returns:
        dict: The modified stats dictionary with nature multipliers applied.
              Returns the original stats if nature details cannot be fetched.
    """
    nature_details = get_nature_details(nature_name)

    if not nature_details:
        print(f"Could not apply nature '{nature_name}'.")
        return stats

    modified_stats = stats.copy()
    up_stat = nature_details["increased"]
    down_stat = nature_details["decreased"]

    if up_stat and up_stat in modified_stats:
        modified_stats[up_stat] = int(modified_stats[up_stat] * 1.1)
    if down_stat and down_stat in modified_stats:
        modified_stats[down_stat] = int(modified_stats[down_stat] * 0.9)

    return modified_stats

def apply_item_boost(stats, held_item):
    """
    Applies the stat multipliers based on a held item to a Pokémon's stats.

    Args:
        stats (dict): A dictionary of a Pokémon's calculated stats.
        held_item (str): The name of the held item.

    Returns:
        dict: The modified stats dictionary with item multipliers applied.
              Returns the original stats if the item doesn't provide a direct stat boost or is not found.
    """
    modified_stats = stats.copy()
    if held_item and held_item in item_multipliers:
        item_multiplier_data = item_multipliers[held_item]
        stat_to_boost = item_multiplier_data.get("stat")
        multiplier = item_multiplier_data.get("multiplier")

        # Apply multiplier only to relevant stats and if multiplier exists
        if stat_to_boost and stat_to_boost.capitalize() in modified_stats and multiplier:
             # Note: Item multipliers on stats are typically applied *after* stat calculation
             # in competitive play, but we are applying it here for simplicity as per the prompt.
             modified_stats[stat_to_boost.capitalize()] = modified_stats[stat_to_boost.capitalize()] * multiplier
        elif stat_to_boost in ["priority", "screens"]:
             # Handle items that don't provide direct stat boosts
             pass # No stat modification needed for these
        else:
            # Item found in multipliers but no stat/multiplier or stat not in calculated stats
            # print(f"Warning: Item '{held_item}' does not provide a directly applicable stat boost in this function.")
            pass # No stat modification needed


    return modified_stats


def calculate_actual_stats(base_stats, level, nature_name, held_item=None, iv=31, ev_dict=None):
    """
    Calculates a Pokémon's actual stats, applying nature and item boosts.

    Args:
        base_stats (dict): A dictionary of a Pokémon's base stats.
        level (int): The Pokémon's level.
        nature_name (str): The name of the nature to apply.
        held_item (str, optional): The name of the held item. Defaults to None.
        iv (int, optional): The Individual Value for all stats. Defaults to 31.
        ev_dict (dict, optional): A dictionary of Effort Values per stat (e.g., {'attack': 252}). Defaults to None.

    Returns:
        dict: The calculated actual stats dictionary. Returns None if total EVs exceed the limit.
    """
    if ev_dict is None:
        ev_dict = {}

    # Check total EVs
    total_evs = sum(ev_dict.values())
    if total_evs > 510:
        print(f"Error: Total EVs ({total_evs}) exceed the maximum allowed (510).")
        return None

    raw_stats = {}

    for stat, base in base_stats.items():
        stat_key = stat.lower()
        ev = ev_dict.get(stat_key, 0)

        if stat_key == "hp":
            raw_stats["HP"] = calculate_hp(base, iv, ev, level)
        else:
             # Calculate raw stat before nature/item
            raw_stats[stat.capitalize()] = calculate_stat(base, iv, ev, level, nature_mod=1.0)

    # Apply nature boost
    nature_boosted_stats = apply_nature_to_stats(raw_stats, nature_name)

    # Apply item boost
    final_stats = apply_item_boost(nature_boosted_stats, held_item)

    return final_stats

# Test the functions
bulbasaur_base_stats = {
    "hp": 45,
    "attack": 49,
    "defense": 49,
    "special-attack": 65,
    "special-defense": 65,
    "speed": 45
}

bulbasaur_evs = {
    "attack": 252,
    "special-attack": 252,
    "speed": 6
}

calculated_bulbasaur_stats = calculate_actual_stats(
    bulbasaur_base_stats,
    level=50,
    nature_name="modest",
    held_item="life-orb",
    iv=31,
    ev_dict=bulbasaur_evs
)

print("Calculated Bulbasaur Stats (Level 50, Modest Nature, Life Orb, Max IVs, 252 Atk, 252 Sp.Atk, 6 Spd EVs):")
pprint.pprint(calculated_bulbasaur_stats)

"""**Reasoning**:
Define the calculate_damage function incorporating type effectiveness.


"""

def apply_nature_to_stats(stats, nature_name):
    """
    Applies the stat multipliers based on a nature to a Pokémon's stats.

    Args:
        stats (dict): A dictionary of a Pokémon's base stats.
        nature_name (str): The name of the nature to apply.

    Returns:
        dict: The modified stats dictionary with nature multipliers applied.
              Returns the original stats if nature details cannot be fetched.
    """
    nature_details = get_nature_details(nature_name)

    if not nature_details:
        print(f"Could not apply nature '{nature_name}'.")
        return stats

    modified_stats = stats.copy()
    up_stat = nature_details["increased"]
    down_stat = nature_details["decreased"]

    if up_stat and up_stat in modified_stats:
        modified_stats[up_stat] = int(modified_stats[up_stat] * 1.1)
    if down_stat and down_stat in modified_stats:
        modified_stats[down_stat] = int(modified_stats[down_stat] * 0.9)

    return modified_stats

def apply_item_boost(stats, held_item):
    """
    Applies the stat multipliers based on a held item to a Pokémon's stats.

    Args:
        stats (dict): A dictionary of a Pokémon's calculated stats.
        held_item (str): The name of the held item.

    Returns:
        dict: The modified stats dictionary with item multipliers applied.
              Returns the original stats if the item doesn't provide a direct stat boost or is not found.
    """
    modified_stats = stats.copy()
    if held_item and held_item in item_multipliers:
        item_multiplier_data = item_multipliers[held_item]
        stat_to_boost = item_multiplier_data.get("stat")
        multiplier = item_multiplier_data.get("multiplier")

        # Apply multiplier only to relevant stats and if multiplier exists
        if stat_to_boost and stat_to_boost.capitalize() in modified_stats and multiplier:
             # Note: Item multipliers on stats are typically applied *after* stat calculation
             # in competitive play, but we are applying it here for simplicity as per the prompt.
             modified_stats[stat_to_boost.capitalize()] = modified_stats[stat_to_boost.capitalize()] * multiplier
        elif stat_to_boost in ["priority", "screens"]:
             # Handle items that don't provide direct stat boosts
             pass # No stat modification needed for these
        else:
            # Item found in multipliers but no stat/multiplier or stat not in calculated stats
            # print(f"Warning: Item '{held_item}' does not provide a directly applicable stat boost in this function.")
            pass # No stat modification needed


    return modified_stats


def calculate_actual_stats(base_stats, level, nature_name, held_item=None, iv=31, ev_dict=None):
    """
    Calculates a Pokémon's actual stats, applying nature and item boosts.

    Args:
        base_stats (dict): A dictionary of a Pokémon's base stats.
        level (int): The Pokémon's level.
        nature_name (str): The name of the nature to apply.
        held_item (str, optional): The name of the held item. Defaults to None.
        iv (int, optional): The Individual Value for all stats. Defaults to 31.
        ev_dict (dict, optional): A dictionary of Effort Values per stat (e.g., {'attack': 252}). Defaults to None.

    Returns:
        dict: The calculated actual stats dictionary. Returns None if total EVs exceed the limit.
    """
    if ev_dict is None:
        ev_dict = {}

    # Check total EVs
    total_evs = sum(ev_dict.values())
    if total_evs > 510:
        print(f"Error: Total EVs ({total_evs}) exceed the maximum allowed (510).")
        return None

    raw_stats = {}

    for stat, base in base_stats.items():
        stat_key = stat.lower()
        ev = ev_dict.get(stat_key, 0)

        if stat_key == "hp":
            raw_stats["HP"] = calculate_hp(base, iv, ev, level)
        else:
             # Calculate raw stat before nature/item
            raw_stats[stat.capitalize()] = calculate_stat(base, iv, ev, level, nature_mod=1.0)

    # Apply nature boost
    nature_boosted_stats = apply_nature_to_stats(raw_stats, nature_name)

    # Apply item boost
    final_stats = apply_item_boost(nature_boosted_stats, held_item)

    return final_stats

def calculate_damage(attacker, defender, move, level, critical=False, effectiveness=1.0, item_boost=1.0):
    """
    Calculates the damage a move deals to a Pokémon, including type effectiveness and STAB.

    Args:
        attacker (dict): A dictionary of the attacking Pokémon's data.
                         Must include 'Base Stats' and 'Types'.
        defender (dict): A dictionary of the defending Pokémon's data.
                         Must include 'Base Stats' and 'Types'.
        move (dict): A dictionary of the move's data.
                     Must include 'power', 'type', and 'damage_class'.
        level (int): The level of the attacking Pokémon.
        critical (bool, optional): Whether the hit is critical. Defaults to False.
        effectiveness (float, optional): The type effectiveness multiplier. Defaults to 1.0.
        item_boost (float, optional): The item damage boost multiplier. Defaults to 1.0.

    Returns:
        int: The calculated damage dealt. Returns 0 for status moves or if required data is missing.
    """
    # Ensure required keys are present
    if "Base Stats" not in attacker or "Types" not in attacker or "Base Stats" not in defender or "Types" not in defender:
        print("Error: Attacker or Defender data is missing required keys.")
        return 0

    # Get base stats
    if move["damage_class"] == "physical":
        atk_stat = attacker["Base Stats"].get("attack")
        def_stat = defender["Base Stats"].get("defense")
    elif move["damage_class"] == "special":
        atk_stat = attacker["Base Stats"].get("special-attack")
        def_stat = defender["Base Stats"].get("special-defense")
    else: # Status move
        return 0

    # Check if required stats are available
    if atk_stat is None or def_stat is None:
         print(f"Error: Missing required stats for damage calculation ({move['damage_class']}).")
         return 0


    # Base power of the move
    power = move["power"]

    # Handle status moves (power is None)
    if power is None:
        return 0 # Status moves don't deal direct damage


    # Base damage before modifiers
    # Note: This formula is a simplified version. Actual Pokemon damage calculation is more complex.
    if def_stat == 0: # Avoid division by zero
        base_damage = 0
    else:
        base_damage = (((2 * level / 5 + 2) * power * atk_stat / def_stat) / 50) + 2

    # Critical hit multiplier
    crit_multiplier = 1.5 if critical else 1.0

    # Random factor (usually between 0.85 and 1.00)
    random_factor = round(random.uniform(0.85, 1.0), 2)

    # Calculate STAB
    stab_multiplier = 1.5 if move["type"] in attacker["Types"] else 1.0

    # Calculate type effectiveness multiplier (using the effectiveness parameter passed in)
    # The effectiveness calculation function was already implemented in a previous step.

    # Final damage calculation
    final_damage = base_damage * stab_multiplier * effectiveness * crit_multiplier * item_boost * random_factor

    return int(final_damage)

def filter_by_generation(pokemon_list, gen_label):
    """Filters a list of Pokémon by generation."""
    if gen_label == "All":
        return pokemon_list
    return [pokemon for pokemon in pokemon_list if pokemon.get("generation") == gen_label]

def filter_by_type(pokemon_list, type_label):
    """Filters a list of Pokémon by type."""
    if type_label == "All":
        return pokemon_list
    return [pokemon for pokemon in pokemon_list if type_label in pokemon.get("Types", [])]

def filter_by_min_stat(pokemon_list, min_stat_value):
    """Filters a list of Pokémon by minimum total base stats."""
    return [pokemon for pokemon in pokemon_list if pokemon.get("Total Base Stats", 0) >= min_stat_value]

def apply_filters(pokemon_list, gen_label="All", type_label="All", min_stat_value=0):
    """Applies multiple filters to a list of Pokémon."""
    filtered_list = filter_by_generation(pokemon_list, gen_label)
    filtered_list = filter_by_type(filtered_list, type_label)
    filtered_list = filter_by_min_stat(filtered_list, min_stat_value)
    return filtered_list

import re
    import requests

def get_move_data(move_name):
    """
    Fetch detailed move data from PokéAPI with name normalization.
    """


    base_url = "https://pokeapi.co/api/v2/move/"

    # Normalize name: lowercase, hyphens instead of spaces, remove apostrophes/periods
    normalized_name = move_name.strip().lower()
    normalized_name = normalized_name.replace(" ", "-").replace("'", "").replace(".", "")
    normalized_name = re.sub(r"[^\w\-]", "", normalized_name)  # remove any remaining non-URL-safe chars

    url = f"{base_url}{normalized_name}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        move = response.json()

        # Find the English effect entry
        english_effect_entry = next((entry for entry in move.get("effect_entries", []) if entry.get("language", {}).get("name") == "en"), None)
        short_effect = english_effect_entry.get("short_effect") if english_effect_entry else "No effect info."

        return {
            "name": move["name"],
            "type": move["type"]["name"],
            "power": move["power"],
            "accuracy": move["accuracy"],
            "pp": move["pp"],
            "damage_class": move["damage_class"]["name"],
            "effect_chance": move.get("effect_chance"),
            "short_effect": short_effect,
            "meta": move.get("meta", {})
        }
    except requests.exceptions.RequestException as e:
        print(f"⚠️ Could not retrieve move data for '{move_name}': {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred while processing move '{move_name}' data: {e}")
        return None

# Get a list of all pokemon names from the loaded data
if 'all_pokemon_data' in globals() and all_pokemon_data:
    all_pokemon_names = [p['Name'] for p in all_pokemon_data]
else:
    all_pokemon_names = []
    print("Warning: all_pokemon_data not found or empty. Pokémon dropdowns will be empty.")


# Define a list of common competitive natures (can be expanded)
common_natures = [
    "Adamant", "Modest", "Jolly", "Timid", "Brave", "Quiet", "Relaxed",
    "Sassy", "Bold", "Impish", "Careful", "Calm", "Gentle",
    "Naive", "Hasty", "Lax", "Naughty", "Lonely", "Hardy", "Docile", "Bashful",
    "Quirky", "Serious"
]

# Extract item names from the item_multipliers dictionary
if 'item_multipliers' in globals():
    held_item_options = ["None"] + sorted(list(item_multipliers.keys()))
else:
    held_item_options = ["None"]
    print("Warning: item_multipliers not found. Item dropdowns will only contain 'None'.")


# Define stat names for EV/IV inputs
stat_names = ['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed']

# Create nested lists of widgets for Team 1 and Team 2
team1_pokemon_widgets = []
for i in range(6):
    pokemon_dropdown = widgets.Dropdown(options=["Select Pokémon"] + sorted(all_pokemon_names), description=f'Team 1 Pokémon {i+1}:', disabled=False)
    move_dropdowns = [
        widgets.Dropdown(options=["Select Move"], description=f'Move {j+1}:', disabled=True) for j in range(4)
    ]
    nature_dropdown = widgets.Dropdown(options=["Select Nature"] + common_natures, description='Nature:', disabled=False)
    item_dropdown = widgets.Dropdown(options=held_item_options, description='Item:', disabled=False)

    # Create EV and IV input fields for each stat
    ev_inputs = [widgets.IntText(value=0, description=f'{stat} EV:', disabled=False, min=0, max=252) for stat in stat_names]
    iv_inputs = [widgets.IntText(value=31, description=f'{stat} IV:', disabled=False, min=0, max=31) for stat in stat_names]

    # Group EV and IV inputs
    ev_box = widgets.VBox(ev_inputs, layout=widgets.Layout(border='1px solid lightgrey', padding='10px', margin='5px'))
    iv_box = widgets.VBox(iv_inputs, layout=widgets.Layout(border='1px solid lightgrey', padding='10px', margin='5px'))

    # Create a box for stat inputs (EVs and IVs side by side)
    stat_inputs_box = widgets.HBox([ev_box, iv_box])


    pokemon_box = widgets.VBox([pokemon_dropdown] + move_dropdowns + [nature_dropdown, item_dropdown, widgets.Label("Stats (EVs/IVs):"), stat_inputs_box], layout=widgets.Layout(border='2px solid blue', padding='10px', margin='10px'))
    team1_pokemon_widgets.append({
        'pokemon_dropdown': pokemon_dropdown,
        'move_dropdowns': move_dropdowns,
        'nature_dropdown': nature_dropdown,
        'item_dropdown': item_dropdown,
        'ev_inputs': ev_inputs,
        'iv_inputs': iv_inputs,
        'box': pokemon_box
    })

team2_pokemon_widgets = []
for i in range(6):
    pokemon_dropdown = widgets.Dropdown(options=["Select Pokémon"] + sorted(all_pokemon_names), description=f'Team 2 Pokémon {i+1}:', disabled=False)
    move_dropdowns = [
        widgets.Dropdown(options=["Select Move"], description=f'Move {j+1}:', disabled=True) for j in range(4)
    ]
    nature_dropdown = widgets.Dropdown(options=["Select Nature"] + common_natures, description='Nature:', disabled=False)
    item_dropdown = widgets.Dropdown(options=held_item_options, description='Item:', disabled=False)

    # Create EV and IV input fields for each stat
    ev_inputs = [widgets.IntText(value=0, description=f'{stat} EV:', disabled=False, min=0, max=252) for stat in stat_names]
    iv_inputs = [widgets.IntText(value=31, description=f'{stat} IV:', disabled=False, min=0, max=31) for stat in stat_names]

     # Group EV and IV inputs
    ev_box = widgets.VBox(ev_inputs, layout=widgets.Layout(border='1px solid lightgrey', padding='10px', margin='5px'))
    iv_box = widgets.VBox(iv_inputs, layout=widgets.Layout(border='1px solid lightgrey', padding='10px', margin='5px'))

    # Create a box for stat inputs (EVs and IVs side by side)
    stat_inputs_box = widgets.HBox([ev_box, iv_box])


    pokemon_box = widgets.VBox([pokemon_dropdown] + move_dropdowns + [nature_dropdown, item_dropdown, widgets.Label("Stats (EVs/IVs):"), stat_inputs_box], layout=widgets.Layout(border='2px solid blue', padding='10px', margin='10px'))
    team2_pokemon_widgets.append({
        'pokemon_dropdown': pokemon_dropdown,
        'move_dropdowns': move_dropdowns,
        'nature_dropdown': nature_dropdown,
        'item_dropdown': item_dropdown,
        'ev_inputs': ev_inputs,
        'iv_inputs': iv_inputs,
        'box': pokemon_box
    })


# Function to update move dropdowns when a Pokémon is selected
def update_move_dropdowns(change, move_dropdowns):
    selected_pokemon_name = change['new']
    if selected_pokemon_name != "Select Pokémon":
        pokemon_data = next((p for p in all_pokemon_data if p["Name"] == selected_pokemon_name), None)
        if pokemon_data and 'Moves' in pokemon_data:
            available_moves = sorted(pokemon_data['Moves'])
            move_options = ["Select Move"] + available_moves
            for move_dropdown in move_dropdowns:
                move_dropdown.options = move_options
                move_dropdown.disabled = False
                move_dropdown.value = "Select Move" # Reset value
        else:
            for move_dropdown in move_dropdowns:
                move_dropdown.options = ["Select Move"]
                move_dropdown.disabled = True
                move_dropdown.value = "Select Move"
    else:
        for move_dropdown in move_dropdowns:
            move_dropdown.options = ["Select Move"]
            move_dropdown.disabled = True
            move_dropdown.value = "Select Move"


# Link the update function to each Pokémon dropdown
for team_widgets in [team1_pokemon_widgets, team2_pokemon_widgets]:
    for pokemon_widgets in team_widgets:
        pokemon_widgets['pokemon_dropdown'].observe(
            lambda change, move_dropdowns=pokemon_widgets['move_dropdowns']: update_move_dropdowns(change, move_dropdowns),
            names='value'
        )

# Create buttons and other UI elements
evaluate_button = widgets.Button(
    description='Simulate Battle & Predict',
    disabled=False,
    button_style='info', # 'primary', 'success', 'info', 'warning', 'danger' or ''
    tooltip='Simulate battles and predict outcome',
    icon='play'
)

randomize_button = widgets.Button(
    description='Randomize Teams & Predict',
    disabled=False,
    button_style='success',
    tooltip='Randomly select teams and simulate battles',
    icon='random'
)

general_report_button = widgets.Button(
    description='Generate Synergy Report (Team 1)',
    disabled=False,
    button_style='primary',
    tooltip='Generate a general synergy report for Team 1',
    icon='file-text'
)


level_dropdown = widgets.Dropdown(
    options=[50, 100],
    value=50,
    description='Level:',
    disabled=False,
)

num_simulations_slider = widgets.IntSlider(
    value=100,
    min=10,
    max=1000,
    step=10,
    description='Simulations:',
    disabled=False,
    continuous_update=False,
    orientation='horizontal',
    readout=True,
    readout_format='d'
)

output_area_battle = widgets.Output()


# Define the function to handle general synergy report button clicks
def on_general_report_button_clicked(b):
    with output_area_battle:
        clear_output(wait=True)

        # Get selected Pokémon names from dropdowns for Team 1
        team1_names = [dropdown.value for dropdown in [pw['pokemon_dropdown'] for pw in team1_pokemon_widgets] if dropdown.value != "Select Pokémon"]


        if not team1_names:
            print("Please select at least one Pokémon for Team 1 to generate a general report.")
            return

        # Limit the number of Pokémon to 6
        team1_names = team1_names[:6]

        # Get the selected level
        selected_level = level_dropdown.value

        # Fetch the base Pokémon data for the selected names
        team1_data = [get_pokemon_data(name) for name in team1_names]
        team1_data = [p for p in team1_data if p and 'Name' in p and 'Base Stats' in p and 'Types' in p] # Filter out invalid data


        team1_battle_ready = []
        stat_names = ['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed'] # Define stat_names here

        # Prepare Team 1 (using selected details from UI)
        for i, pokemon_data in enumerate(team1_data):
            pokemon_widget = next((pw for pw in team1_pokemon_widgets if pw['pokemon_dropdown'].value == pokemon_data['Name']), None)

            if pokemon_widget:
                 selected_moves = [md.value for md in pokemon_widget['move_dropdowns'] if md.value != "Select Move"]
                 selected_nature = pokemon_widget['nature_dropdown'].value
                 selected_item = pokemon_widget['item_dropdown'].value

                 # Get selected EVs and IVs from the widgets
                 selected_evs = {stat_names[j].lower(): ev_widget.value for j, ev_widget in enumerate(pokemon_widget['ev_inputs'])}
                 selected_ivs = {stat_names[j].lower(): iv_widget.value for j, iv_widget in enumerate(pokemon_widget['iv_inputs'])}


                 prepared_pokemon = prepare_pokemon_for_battle(
                     pokemon_data,
                     selected_level,
                     selected_moves,
                     selected_nature,
                     selected_item,
                     iv_dict=selected_ivs,
                     ev_dict=selected_evs
                 )
                 if prepared_pokemon:
                     team1_battle_ready.append(prepared_pokemon)
                 else:
                      print(f"Skipping {pokemon_data.get('Name', 'Unknown Pokemon')} due to preparation error.")
            else:
                 print(f"Warning: Could not find widget for selected Pokémon: {pokemon_data['Name']}")


        if not team1_battle_ready:
            print("Could not prepare team for synergy report. Ensure selected Pokémon names are valid.")
            return

        # Generate and display the general synergy report
        synergy_report_markdown = generate_team_synergy_report(team1_battle_ready, type_effectiveness_data, selected_level)
        display(Markdown(synergy_report_markdown))



# Define the function to handle evaluate button clicks
def on_evaluate_button_clicked(b):
    with output_area_battle:
        clear_output(wait=True)

        # Get selected Pokémon names from dropdowns for both teams
        team1_names = [dropdown.value for dropdown in [pw['pokemon_dropdown'] for pw in team1_pokemon_widgets] if dropdown.value != "Select Pokémon"]
        team2_names = [dropdown.value for dropdown in [pw['pokemon_dropdown'] for pw in team2_pokemon_widgets] if dropdown.value != "Select Pokémon"]


        if not team1_names or not team2_names:
            print("Please select at least one Pokémon for each team.")
            return

        # Limit the number of Pokémon to 6 per team
        team1_names = team1_names[:6]
        team2_names = team2_names[:6]

        # Get the selected level and number of simulations
        selected_level = level_dropdown.value
        num_sims = num_simulations_slider.value

        team1_battle_ready = []
        stat_names = ['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed'] # Define stat_names here

        # Prepare Team 1
        for i, pokemon_widgets in enumerate(team1_pokemon_widgets): # Iterate through widgets to get inputs
            selected_pokemon_name = pokemon_widgets['pokemon_dropdown'].value
            if selected_pokemon_name != "Select Pokémon":
                pokemon_data = next((p for p in all_pokemon_data if p["Name"] == selected_pokemon_name), None)
                if pokemon_data:
                    selected_moves = [md.value for md in pokemon_widgets['move_dropdowns'] if md.value != "Select Move"]
                    selected_nature = pokemon_widgets['nature_dropdown'].value
                    selected_item = pokemon_widgets['item_dropdown'].value

                    # Get selected EVs and IVs from the widgets
                    selected_evs = {stat_names[j].lower(): ev_widget.value for j, ev_widget in enumerate(pokemon_widgets['ev_inputs'])}
                    selected_ivs = {stat_names[j].lower(): iv_widget.value for j, iv_widget in enumerate(pokemon_widgets['iv_inputs'])}

                    prepared_pokemon = prepare_pokemon_for_battle(
                        pokemon_data,
                        selected_level,
                        selected_moves,
                        selected_nature,
                        selected_item,
                        iv_dict=selected_ivs,
                        ev_dict=selected_evs
                    )
                    if prepared_pokemon:
                        team1_battle_ready.append(prepared_pokemon)
                    else:
                         # Handle case where stat calculation failed (e.g. invalid EVs)
                         print(f"Skipping {pokemon_data.get('Name', 'Unknown Pokemon')} due to stat calculation error.")
                else:
                    print(f"Warning: Data not found for Pokémon: {selected_pokemon_name}")


        team2_battle_ready = []
        # Prepare Team 2 (using the same logic)
        for i, pokemon_widgets in enumerate(team2_pokemon_widgets): # Iterate through widgets
             selected_pokemon_name = pokemon_widgets['pokemon_dropdown'].value
             if selected_pokemon_name != "Select Pokémon":
                pokemon_data = next((p for p in all_pokemon_data if p["Name"] == selected_pokemon_name), None)
                if pokemon_data:
                     selected_moves = [md.value for md in pokemon_widgets['move_dropdowns'] if md.value != "Select Move"]
                     selected_nature = pokemon_widgets['nature_dropdown'].value
                     selected_item = pokemon_widgets['item_dropdown'].value

                     # Get selected EVs and IVs from the widgets
                     selected_evs = {stat_names[j].lower(): ev_widget.value for j, ev_widget in enumerate(pokemon_widgets['ev_inputs'])}
                     selected_ivs = {stat_names[j].lower(): iv_widget.value for j, iv_widget in enumerate(pokemon_widgets['iv_inputs'])}

                     prepared_pokemon = prepare_pokemon_for_battle(
                         pokemon_data,
                         selected_level,
                         selected_moves,
                         selected_nature,
                         selected_item,
                         iv_dict=selected_ivs,
                         ev_dict=selected_evs
                     )
                     if prepared_pokemon:
                         team2_battle_ready.append(prepared_pokemon)
                     else:
                         # Handle case where stat calculation failed (e.g. invalid EVs)
                         print(f"Skipping {pokemon_data.get('Name', 'Unknown Pokemon')} due to stat calculation error.")
                else:
                    print(f"Warning: Data not found for Pokémon: {selected_pokemon_name}")


        if not team1_battle_ready or not team2_battle_ready:
            print("Please select at least one valid Pokémon for each team to simulate a battle.")
            return

        print(f"Team 1: {[p['Name'].capitalize() for p in team1_battle_ready]}")
        print(f"Team 2: {[p['Name'].capitalize() for p in team2_battle_ready]}")


        # --- Perform Battle Prediction ---
        # predict_battle_outcome now returns synergy reports
        prediction_result = predict_battle_outcome(team1_battle_ready, team2_battle_ready, selected_level, num_sims, type_effectiveness_data)


        # --- Display Battle Prediction Results ---
        print("\n# --- Battle Prediction Results ---")
        print(f"## Predicted Outcome: {prediction_result.get('predicted_outcome', 'N/A')}")
        print(f"Team 1 Wins: {prediction_result.get('team1_wins', 0)} ({prediction_result.get('team1_win_percentage', 0):.2f}%)")
        print(f"Team 2 Wins: {prediction_result.get('team2_wins', 0)} ({prediction_result.get('team2_win_percentage', 0):.2f}%)")
        print(f"Draws: {prediction_result.get('draws', 0)} ({prediction_result.get('draw_percentage', 0):.2f}%)")


        # --- Display Synergy Reports from Battle Outcome ---
        team1_synergy_report = prediction_result.get('team1_synergy_report')
        team2_synergy_report = prediction_result.get('team2_synergy_report')

        if team1_synergy_report:
            display(Markdown(team1_synergy_report)) # Display the markdown report for Team 1
        if team2_synergy_report:
            display(Markdown(team2_synergy_report)) # Display the markdown report for Team 2


# Define the function to handle randomization and evaluation
def on_randomize_button_clicked(b):
    with output_area_battle:
        clear_output(wait=True)
        if len(all_pokemon_data) < 12: # Need at least 12 for two full teams
            print("Not enough Pokémon data available to form two random teams.")
            return

        # Randomly select up to 6 unique Pokémon for each team
        random_team1_data_base = random.sample(all_pokemon_data, min(6, len(all_pokemon_data) // 2))
        remaining_pokemon = [p for p in all_pokemon_data if p not in random_team1_data_base]
        random_team2_data_base = random.sample(remaining_pokemon, min(6, len(remaining_pokemon)))

        # Get the selected level and number of simulations
        selected_level = level_dropdown.value
        num_sims = num_simulations_slider.value

        # Prepare random teams with randomized moves, nature, and item, EVs, and IVs
        random_team1_battle_ready = []
        stat_names = ['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed'] # Define stat_names here

        for pokemon_data in random_team1_data_base:
            available_moves = pokemon_data.get("Moves", [])
            # Select 4 random moves
            selected_moves = random.sample(available_moves, min(4, len(available_moves)))
            # Select a random nature
            selected_nature = random.choice(common_natures)
            # Select a random item (including "None")
            selected_item = random.choice(held_item_options)

            # Randomize EVs (e.g., distribute 508 EVs randomly)
            selected_evs = {stat.lower(): 0 for stat in stat_names}
            remaining_evs = 508
            while remaining_evs > 0:
                stat_to_boost = random.choice(stat_names).lower()
                # Ensure boost_amount does not exceed 252 or remaining EVs
                boost_amount = random.randint(0, min(remaining_evs, 252 - selected_evs[stat_to_boost]))
                selected_evs[stat_to_boost] += boost_amount
                remaining_evs -= boost_amount

            # Randomize IVs (e.g., between 0 and 31)
            selected_ivs = {stat.lower(): random.randint(0, 31) for stat in stat_names}


            prepared_pokemon = prepare_pokemon_for_battle(
                 pokemon_data,
                 selected_level,
                 selected_moves,
                 selected_nature,
                 selected_item,
                 iv_dict=selected_ivs,
                 ev_dict=selected_evs
            )
            if prepared_pokemon:
                random_team1_battle_ready.append(prepared_pokemon)
            else:
                 print(f"Skipping {pokemon_data.get('Name', 'Unknown Pokemon')} due to stat calculation error.")


        random_team2_battle_ready = []
        for pokemon_data in random_team2_data_base:
             available_moves = pokemon_data.get("Moves", [])
             selected_moves = random.sample(available_moves, min(4, len(available_moves)))
             selected_nature = random.choice(common_natures)
             selected_item = random.choice(held_item_options)

             # Randomize EVs
             selected_evs = {stat.lower(): 0 for stat in stat_names}
             remaining_evs = 508
             while remaining_evs > 0:
                 stat_to_boost = random.choice(stat_names).lower()
                 boost_amount = random.randint(0, min(remaining_evs, 252 - selected_evs[stat_to_boost]))
                 selected_evs[stat_to_boost] += boost_amount
                 remaining_evs -= boost_amount

             # Randomize IVs
             selected_ivs = {stat.lower(): random.randint(0, 31) for stat in stat_names}


             prepared_pokemon = prepare_pokemon_for_battle(
                 pokemon_data,
                 selected_level,
                 selected_moves,
                 selected_nature,
                 selected_item,
                 iv_dict=selected_ivs,
                 ev_dict=selected_evs
             )
             if prepared_pokemon:
                 random_team2_battle_ready.append(prepared_pokemon)
             else:
                 print(f"Skipping {pokemon_data.get('Name', 'Unknown Pokemon')} due to stat calculation error.")



        if not random_team1_battle_ready or not random_team2_battle_ready:
            print("Could not prepare random teams for battle simulation.")
            return

        print(f"Random Team 1: {[p['Name'].capitalize() for p in random_team1_battle_ready]}")
        print(f"Random Team 2: {[p['Name'].capitalize() for p in random_team2_battle_ready]}")


        # --- Perform Battle Prediction for random teams ---
        prediction_result = predict_battle_outcome(random_team1_battle_ready, random_team2_battle_ready, selected_level, num_sims, type_effectiveness_data)


        # --- Display Battle Prediction Results ---
        print("\n# --- Battle Prediction Results ---")
        print(f"## Predicted Outcome: {prediction_result.get('predicted_outcome', 'N/A')}")
        print(f"Team 1 Wins: {prediction_result.get('team1_wins', 0)} ({prediction_result.get('team1_win_percentage', 0):.2f}%)")
        print(f"Team 2 Wins: {prediction_result.get('team2_wins', 0)} ({prediction_result.get('team2_win_percentage', 0):.2f}%)")
        print(f"Draws: {prediction_result.get('draws', 0)} ({prediction_result.get('draw_percentage', 0):.2f}%)")


        # --- Display Synergy Reports from Battle Outcome ---
        team1_synergy_report = prediction_result.get('team1_synergy_report')
        team2_synergy_report = prediction_result.get('team2_synergy_report')

        if team1_synergy_report:
            display(Markdown(team1_synergy_report)) # Display the markdown report for Team 1
        if team2_synergy_report:
            display(Markdown(team2_synergy_report)) # Display the markdown report for Team 2


# Link the buttons to the functions
evaluate_button.on_click(on_evaluate_button_clicked)
randomize_button.on_click(on_randomize_button_clicked)
general_report_button.on_click(on_general_report_button_clicked)

# Display the UI
ui_team1_selection = widgets.VBox([pw['box'] for pw in team1_pokemon_widgets])
ui_team2_selection = widgets.VBox([pw['box'] for pw in team2_pokemon_widgets])

ui_controls = widgets.HBox([evaluate_button, randomize_button, general_report_button, level_dropdown, num_simulations_slider])

print("Select your teams (up to 6 Pokémon each, choose moves, natures, items, EVs, and IVs):")
display(widgets.HBox([ui_team1_selection, ui_team2_selection]), ui_controls, output_area_battle)

import pandas as pd

# Extract the base stats for all Pokémon into a list of dictionaries
base_stats_list = [pokemon['Base Stats'] for pokemon in all_pokemon_data if 'Base Stats' in pokemon]

# Convert the list of dictionaries into a pandas DataFrame
base_stats_df = pd.DataFrame(base_stats_list)

# Display the first few rows of the DataFrame
display(base_stats_df.head())

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Calculate WCSS for different numbers of clusters
wcss = []
# Trying a range of K from 1 to 10 as a starting point
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=42, n_init=10)
    kmeans.fit(base_stats_df)
    wcss.append(kmeans.inertia_)

# Plot the elbow method graph
plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), wcss, marker='o', linestyle='--')
plt.title('Elbow Method')
plt.xlabel('Number of Clusters (K)')
plt.ylabel('WCSS')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

"""**Reasoning**:
Perform K-Means clustering on the base stats DataFrame using K=3.
"""

# Perform K-Means clustering with 3 clusters
kmeans = KMeans(n_clusters=4, init='k-means++', random_state=42, n_init=10)
kmeans.fit(base_stats_df)

# Get the cluster labels for each data point
cluster_labels = kmeans.labels_

# Display the cluster labels (first few)
print("Cluster Labels (first 10):")
print(cluster_labels[:10])

# Display the cluster centroids
print("\nCluster Centroids:")
print(kmeans.cluster_centers_)

from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

# Perform PCA to reduce to 2 dimensions
pca = PCA(n_components=2)
principal_components = pca.fit_transform(base_stats_df)

# Create a DataFrame with the principal components and cluster labels
pca_df = pd.DataFrame(data = principal_components, columns = ['principal component 1', 'principal component 2'])
pca_df['cluster'] = cluster_labels

# Visualize the clusters
plt.figure(figsize=(10, 8))
scatter = plt.scatter(pca_df['principal component 1'], pca_df['principal component 2'], c=pca_df['cluster'], cmap='viridis', s=50, alpha=0.6)
plt.title('Pokémon Base Stats Clustering (PCA)')
plt.xlabel('Overall Stat Level (PC1)') # More descriptive label
plt.ylabel('Stat Distribution Skew (PC2)') # More descriptive label
plt.colorbar(scatter, label='Cluster Label')
plt.grid(True)
plt.show()

# Get unique clusters and assign each a color
unique_clusters = pca_df['cluster'].unique()
colors = cm.get_cmap('viridis', len(unique_clusters))

plt.figure(figsize=(10, 8))

for i, cluster in enumerate(unique_clusters):
    cluster_data = pca_df[pca_df['cluster'] == cluster]
    plt.scatter(
        cluster_data['principal component 1'],
        cluster_data['principal component 2'],
        s=100,
        facecolors='none',  # clear center
        edgecolors=colors(i),  # color ring
        linewidths=1,
        label=f'Cluster {cluster}',
        alpha=0.9
    )

plt.title('Pokemon Base Stat PCA - Clusters')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.legend(title='Cluster')
plt.show()

stats_by_character = {"HP":{"Charizard":143, "Blastoise":165},
                       "Speed":{"Charizard":120, "Blastoise":70}}
n_stats = len(stats_by_character)
# Set colors of plot symbols, by character character.  As an example,
color_by_character = {"Charizard":(0, 0, 1), "Blastoise":(0, 0.5, 0)}
n_characters = len(color_by_character)

# Set legend entries (open circle as symbol, character name as label)
labels = color_by_character.keys()
handles = [mlines.Line2D([], [], color=color_by_character[character],
                         marker='o', markerfacecolor="None",
                         linewidth=0, label=character)
           for character in labels]

fig, ax = plt.subplots()
fig.set_size_inches((6, 2))
for i, stat in enumerate(stats_by_character.keys()):
    # Draw gray horizontal line for each stat.
    ax.axhline(i, color=(0.5, 0.5, 0.5), lw=1)
    # Plot characters' levels for each stat as 1-D scatterplots, using
    # open circles color-coded by character.
    for character in stats_by_character[stat].keys():
        ax.plot(stats_by_character[stat][character], i, "o",
                color=color_by_character[character],
                markerfacecolor="None")
# Add some whitespace above and below the scatterplots.
ax.set_ylim((-0.1*(n_stats - 1), 1.1*(n_stats - 1)))
ax.set_yticks(range(n_stats))
ax.set_yticklabels(stats_by_character.keys())
ax.tick_params(left=False)
# Remove frame of figure except for bottom spine.
for spine in ("left", "top", "right"):
    ax.spines[spine].set_visible(False)
# Add legend above figure.
fig.legend(handles=handles, labels=labels, loc="upper center",
           ncols=n_stats, labelcolor="linecolor",
           handletextpad=0.1, frameon=False)
# Expand the left and bottom margins of the figure.
fig.subplots_adjust(left=0.2, bottom=0.2)
fig.show()

# Find some Pokémon in the all_pokemon_data list to use for the example team
pokemon_for_team = []
pokemon_names_to_include = ["charizard", "venusaur", "blastoise"]

for name in pokemon_names_to_include:
    found_pokemon = next((pokemon for pokemon in all_pokemon_data if pokemon["Name"] == name), None)
    if found_pokemon:
        pokemon_for_team.append(found_pokemon)
    else:
        print(f"Warning: Could not find data for {name} in all_pokemon_data.")

# Ensure the example team has at least three Pokémon with required keys
if len(pokemon_for_team) < 3:
    print("Error: Not enough Pokémon found for the example team.")
    # As a fallback, add some default data if not enough were found
    while len(pokemon_for_team) < 3:
        pokemon_for_team.append({
            "Name": f"Placeholder_{len(pokemon_for_team)}",
            "Base Stats": {"hp": 50, "attack": 50, "defense": 50, "special-attack": 50, "special-defense": 50, "speed": 50},
            "Types": ["normal"]
        })

# Store the example team
example_team = pokemon_for_team

# Display the example team to verify
print("Example Pokémon Team:")
pprint.pprint(example_team)

#define offense coverage
def analyze_offensive_coverage(team, type_effectiveness_data):
    """
    Analyzes the team's offensive type coverage.

    Args:
        team (list): A list of Pokémon dictionaries.
        type_effectiveness_data (dict): Data on type effectiveness.

    Returns:
        dict: A dictionary summarizing which defending types the team can hit
              super-effectively (2x or 4x damage).
    """
    offensive_coverage = {
        "super_effective_2x": set(),
        "super_effective_4x": set()
    }
    all_moves = []

    for pokemon in team:
# This avoids fetching full movepools and speeds up analysis.
        pokemon_moves = pokemon.get("Moves", [])
        # Limiting the number of moves checked per pokemon to keep it manageable
        moves_to_check = random.sample(pokemon_moves, min(5, len(pokemon_moves)))

        for move_name in moves_to_check:
            move_data = get_move_data(move_name)
            if move_data and move_data["power"] is not None:
                all_moves.append(move_data)


    all_defending_types = type_effectiveness_data.keys() if type_effectiveness_data else []

    for move in all_moves:
        attacking_type = move["type"]
        for defending_type in all_defending_types:
            # Calculate effectiveness against a single defending type for simplicity here
            # A real scenario would consider the defending pokemon's dual types
            effectiveness = get_type_effectiveness(attacking_type, [defending_type])

            if effectiveness >= 4.0:
                offensive_coverage["super_effective_4x"].add(defending_type)
            elif effectiveness >= 2.0:
                 offensive_coverage["super_effective_2x"].add(defending_type)


    return offensive_coverage

def analyze_defensive_synergy(team, type_effectiveness_data):
    defensive_synergy = {}
    all_attacking_types = type_effectiveness_data.keys() if type_effectiveness_data else []

    for attacking_type in all_attacking_types:
        defensive_synergy[attacking_type] = {
            "resistances": [], # 0.5x or 0.25x
            "weaknesses": [],  # 2x or 4x
            "immunities": []   # 0x
        }
        for pokemon in team:
            defender_types = pokemon.get("Types", [])
            if defender_types:
                 effectiveness = get_type_effectiveness(attacking_type, defender_types)

                 if effectiveness == 0.0:
                     defensive_synergy[attacking_type]["immunities"].append(pokemon["Name"])
                 elif effectiveness <= 0.5:
                     defensive_synergy[attacking_type]["resistances"].append(pokemon["Name"])
                 elif effectiveness >= 2.0:
                     defensive_synergy[attacking_type]["weaknesses"].append(pokemon["Name"])
            else:
                 # Handle cases where a pokemon might not have types defined
                 pass # No type matchups to record for this pokemon


    return defensive_synergy

# Call the functions with the example team and type effectiveness data
offensive_results = analyze_offensive_coverage(example_team, type_effectiveness_data)
defensive_results = analyze_defensive_synergy(example_team, type_effectiveness_data)

print("\nOffensive Coverage Analysis")
print("Can hit for 2x+ damage against types:")
print(f"  2x Super Effective: {list(offensive_results['super_effective_2x'])}")
print(f"  4x Super Effective: {list(offensive_results['super_effective_4x'])}")


print("\nDefensive Synergy Analysis")
# Print a summary of defensive matchups
for attacking_type, matchups in defensive_results.items():
    if matchups["immunities"] or matchups["resistances"] or matchups["weaknesses"]:
        print(f"\nAttacking Type: {attacking_type}")
        if matchups["immunities"]:
            print(f"  Immunities (0x): {', '.join(matchups['immunities'])}")
        if matchups["resistances"]:
            print(f"  Resistances (0.5x or 0.25x): {', '.join(matchups['resistances'])}")
        if matchups["weaknesses"]:
            print(f"  Weaknesses (2x or 4x): {', '.join(matchups['weaknesses'])}")

team_data = [{'Name': pokemon['Name'], 'Base Stats': pokemon['Base Stats']} for pokemon in example_team]
team_df = pd.DataFrame(team_data)

# 2. Expand the 'Base Stats' dictionary column into separate columns
base_stats_expanded = team_df['Base Stats'].apply(pd.Series)
team_stats_df = pd.concat([team_df['Name'], base_stats_expanded], axis=1)

# Rename columns to be capitalized for consistency with previous stat calculations
team_stats_df.columns = ['Name', 'HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed']


# 3. Calculate and print descriptive statistics
print("Team Base Stat Distribution Statistics")
display(team_stats_df[['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed']].describe())

# 4. Create a strip plot to visualize the distribution of each base stat
plt.figure(figsize=(12, 7))
# Reshape the DataFrame for the strip plot
team_stats_melted = team_stats_df.melt(id_vars='Name', var_name='Stat', value_name='Value')

# Create the strip plot
sns.stripplot(data=team_stats_melted, x='Stat', y='Value', hue='Name', dodge=True, size=7, alpha=0.7)

plt.title('Distribution of Base Stats Across the Team (Individual Pokémon)')
plt.ylabel('Base Stat Value')
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.legend(title='Pokémon', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout() # Adjust layout to prevent legend from overlapping
plt.show()

# Step 1: Create the team stats dataframe
team_data = [{'Name': pokemon['Name'], 'Base Stats': pokemon['Base Stats']} for pokemon in example_team]
team_df = pd.DataFrame(team_data)
base_stats_expanded = team_df['Base Stats'].apply(pd.Series)
team_stats_df = pd.concat([team_df['Name'], base_stats_expanded], axis=1)
team_stats_df.columns = ['Name', 'HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed']

# Step 2: Convert dataframe into dictionary of stats by stat name
stats_by_character = {}
stat_names = ['HP', 'Attack', 'Defense', 'Special-attack', 'Special-defense', 'Speed']
for stat in stat_names:
    stats_by_character[stat] = dict(zip(team_stats_df['Name'], team_stats_df[stat]))

# Step 3: Assign unique colors to each Pokémon
names = team_stats_df['Name'].unique()
cmap = cm.get_cmap('tab10', len(names))  # Or use 'viridis', 'Set2', etc.
color_by_character = {name: cmap(i) for i, name in enumerate(names)}

# Step 4: Build the plot
n_stats = len(stat_names)

# Legend handles
handles = [
    mlines.Line2D([], [], color=color_by_character[name], marker='o',
                  markerfacecolor='none', linewidth=0, label=name)
    for name in names
]

fig, ax = plt.subplots(figsize=(10, 4.5))

for i, stat in enumerate(stat_names):
    ax.axhline(i, color='gray', lw=1, alpha=0.3)
    for name in stats_by_character[stat].keys():
        ax.plot(stats_by_character[stat][name], i, 'o',
                color=color_by_character[name], markerfacecolor='none',
                markersize=8, linewidth=1.2)

# Tidy up axes
ax.set_yticks(range(n_stats))
ax.set_yticklabels(stat_names)
ax.set_ylim(-0.5, n_stats - 0.5)
ax.tick_params(left=False)
ax.spines[['top', 'left', 'right']].set_visible(False)

# Legend and formatting
fig.legend(handles=handles, title='Pokémon', loc='upper center', ncol=len(names),
           handletextpad=0.3, frameon=False)
plt.title("Base Stats per Pokémon (1-D Scatterplot)")
plt.xlabel("Base Stat Value")
plt.grid(axis='x', linestyle='--', alpha=0.5)
fig.subplots_adjust(top=0.8, left=0.2)

plt.show()

# 1. Fetch Ability Details
team_abilities_data = {}
for pokemon in example_team:
    pokemon_name = pokemon["Name"]
    team_abilities_data[pokemon_name] = []
    if 'abilities' in pokemon.get('Base Stats', {}):
        pokemon_in_all_data = next((p for p in all_pokemon_data if p["Name"] == pokemon_name), None)
        if pokemon_in_all_data and 'abilities' in pokemon_in_all_data:
             abilities_list = pokemon_in_all_data['abilities']
             for ability_entry in abilities_list:
                ability_name = ability_entry['ability']['name']
                team_abilities_data[pokemon_name].append(ability_name)
        else:
            print(f"Could not find abilities for {pokemon_name} in all_pokemon_data.")
    else:
        # Fallback: try fetching directly if not in the stored data (might be slow)
        try:
            url = f"https://pokeapi.co/api/v2/pokemon/{pokemon_name.lower()}"
            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()
                abilities_list = data['abilities']
                for ability_entry in abilities_list:
                    team_abilities_data[pokemon_name].append(ability_entry['ability']['name'])
            else:
                print(f"Could not fetch abilities for {pokemon_name} from API.")
        except Exception as e:
            print(f"Error fetching abilities for {pokemon_name}: {e}")


print("\n--- Team Abilities ---")
pprint.pprint(team_abilities_data)


# 2. Fetch Move Details
team_moves_data = {}
for pokemon in example_team:
    pokemon_name = pokemon["Name"]
    team_moves_data[pokemon_name] = []
    pokemon_moves = pokemon.get("Moves", [])
    # Select a representative subset of moves (the first 5 or a random sample)
    moves_to_fetch = pokemon_moves[:5] # Taking the first 5 moves as a subset

    for move_name in moves_to_fetch:
        move_details = get_move_data(move_name) # Assuming get_move_data is available
        if move_details:
            team_moves_data[pokemon_name].append(move_details)
        else:
            print(f"Could not fetch details for move: {move_name}")

print("\nTeam Move Details (Subset)")
pprint.pprint(team_moves_data)


# 3. Analyze Ability Synergy (Basic)
print("\nAbility Synergy Analysis (Basic)")
all_team_abilities = [ability for abilities in team_abilities_data.values() for ability in abilities]
unique_abilities = set(all_team_abilities)

print(f"Unique abilities in the team: {list(unique_abilities)}")

# 4. Analyze Movepool Coverage
print("\nMovepool Coverage Analysis")
# Identify all unique attacking move types in the team's subset of moves
team_attacking_types = set()
for pokemon_moves in team_moves_data.values():
    for move in pokemon_moves:
        if move["power"] is not None: # Only consider attacking moves
            team_attacking_types.add(move["type"])

print(f"Team's attacking move types (from subset): {list(team_attacking_types)}")

# Determine what types these attacking types are super-effective against
combined_offensive_coverage = {
    "super_effective_2x": set(),
    "super_effective_4x": set()
}

all_defending_types = type_effectiveness_data.keys() if type_effectiveness_data else []

for attacking_type in team_attacking_types:
    for defending_type in all_defending_types:
        effectiveness = get_type_effectiveness(attacking_type, [defending_type])
        if effectiveness >= 4.0:
            combined_offensive_coverage["super_effective_4x"].add(defending_type)
        elif effectiveness >= 2.0:
            combined_offensive_coverage["super_effective_2x"].add(defending_type)

print("\nCombined offensive coverage (Super Effective against):")
print(f"  2x Super Effective: {list(combined_offensive_coverage['super_effective_2x'])}")
print(f"  4x Super Effective: {list(combined_offensive_coverage['super_effective_4x'])}")

# 5. Summarize Findings
print("\nSummary of Ability and Movepool Analysis")
print("Abilities Present in the Team:")
for pokemon, abilities in team_abilities_data.items():
    print(f"- {pokemon}: {', '.join(abilities)}")

print("\nCombined Offensive Coverage (based on a subset of moves):")
print(f"The team's moves can hit the following types for at least 2x damage:")
print(f"  {list(combined_offensive_coverage['super_effective_2x'].union(combined_offensive_coverage['super_effective_4x']))}")

print("\nAbility Synergy Notes:")
print("A detailed ability synergy analysis requires specific knowledge of each ability's effect.")
print("Based on names alone, we cannot determine complex interactions.")
print("Further analysis would involve fetching ability effect descriptions and identifying complementary effects (e.g., one ability sets sun, another benefits from sun).")

print("\nMovepool Coverage Notes:")
print("The offensive coverage is based on a small subset of each Pokémon's potential movepool.")
print("A comprehensive analysis would require considering a full competitive moveset for each Pokémon.")
print("Gaps in coverage (types not hit super-effectively) indicate potential defensive walls the team might struggle against.")